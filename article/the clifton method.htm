<html>

<head>
<meta http-equiv="Content-Language" content="en-us">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<title>The Clifton Method</title>
</head>

<body>

<p>The Clifton Method</p>
<p>Guidelines for Writing Applications</p>
<p>Module Manager: Manages instantiation of modules, which are by default 
singleton instances.&nbsp; Normally a module registers services.</p>
<p>Service Manager: Manages registration and instantiation of singleton and 
multiple services instances.&nbsp; Some services register semantic receptors to 
subscribe to specific semantic data on a membrane data bus.</p>
<p>Semantic Processor: Usually implemented as a singleton service, the semantic 
processor is a sophisticated multithreaded publisher/subscriber system that 
allows multiple subscribers to respond to semantic data published on a membrane 
data bus.</p>
<p>Modules are always singletons and can expose interfaces that provide 
functions and properties that are accessible to all services.&nbsp; This is sort 
of a module-specific global store.&nbsp; Use cases for this situation are very 
uncommon.&nbsp; Some modules do not register services.&nbsp; An example is the 
web server service module, which starts a listener thread.</p>
<p>Services typically expose their interface for access by other services to 
service functions and instantiating custom service instances.&nbsp; There are 
use cases where services do not expose their interface, particularly when the 
service sets up a receptor that processes data published on a membrane data bus.</p>
<p>Bootstrap Process:</p>
<ol>
	<li>The service manager is instantiated.</li>
	<li>The module manager is registered as a singleton service.<ol>
		<li>All modules are loaded.</li>
		<li>On completion, modules register services provided by the module.</li>
		<li>Singleton services are automatically instantiated.</li>
	</ol>
	</li>
	<li>Services register any semantic receptors.</li>
	<li>The application starts any listener processes and/or completes its 
	startup process.</li>
</ol>
<p>A typical bootstrap looks like this:</p>
<pre>static void Main(string[] args)
{
  Bootstrap();
  // The rest of application-specific initialization.
}

static void Bootstrap()
{
  serviceManager = new ServiceManager();
  serviceManager.RegisterSingleton&lt;IModuleManager, ModuleManager&gt;();

  try
  {
    IModuleManager moduleMgr = serviceManager.Get&lt;IModuleManager&gt;();
    moduleMgr.RegisterModules(XmlFileName.Create(&quot;modules.xml&quot;));
    serviceManager.FinishedInitialization();
  }
  catch (Exception ex)
  {
    Console.WriteLine(ex.Message);
    Environment.Exit(1);
  }
}</pre>
<p>A bootstrap for an application implementing a REST or web server would have a 
slightly expanded <code>Main</code>:</p>
<pre>static void Main(string[] args)
{
  Bootstrap();
  serviceManager.Get&lt;IWebServerService&gt;().Start();
  // The rest of application-specific initialization.
}</pre>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>Introduction</h2>
<p>A long time ago, someone said to me &quot;I'm not going to use your style of 
programming because I can't put 'Proficient in the Clifton Method&quot; on my resume.&nbsp; 
Well, now you can!&nbsp; All joking aside, I decided to write an article that 
pulls from my 30+ years of experience in writing code, not just documenting my 
approach, but also as a reminder to myself on how I should write code, because 
the honest truth is, I often don't apply my own principles.&nbsp; So, in a 
sense, this is a document to smack over my own head when I cut corners.&nbsp; 
Conversely, when I don't cut corners, I can see tangible results--the mantra 
every major tool maker and open source methodologist always shouts--lower cost, fewer bugs, faster delivery 
time.&nbsp; Ironically, it's not the tool, it's the engineering you use put into 
a coding effort that makes a real difference.&nbsp; And things like TDD and 
Agile--they're not engineering, they are <u>processes</u>.&nbsp; What I'm talking about in this article is
<u>engineering</u>.&nbsp; The engineering principles I'm writing about here can 
be applied any language, not just C#, any platform (not just Windows), and any 
development effort, whether it's a web application, a cloud service, a UI-based 
app, a service, etc.</p>
<h3>Regarding the Code Examples</h3>
<p>There are a lot viable implementations for all the code that I'm 
demonstrating, so take the code examples not as gospel but as they are intended 
to be, examples.&nbsp; The gospel is in the theme of the miracles and not so 
much the miracles themselves.</p>
<h3>A Note about Code Comments</h3>
<p>I'm trying very hard to change my discipline from &quot;what&quot; to &quot;why&quot;, so the 
code comments for various methods should reflect why the method exists and why 
it does what it does, rather than &quot;what&quot;, which should be clear enough from the 
method body.</p>
<h3>What's Ahead</h3>
<p>What I'll be presenting in this article is are the core technologies that I 
believe almost always represent the foundation of a well engineered software 
project.&nbsp; These are:</p>
<ul>
	<li>Critical Exception Handler</li>
	<li>Logging</li>
	<li>Service Management</li>
	<li>Module Management</li>
	<li>State Management</li>
	<li>Semantic Types</li>
	<li>Semantic Processing</li>
</ul>
<p>The centerpiece is shared between the service and module managers, as these 
promote, well, modularity!&nbsp; </p>
<p>[diagram]</p>
<p>The semantic business is one of those &quot;take it or leave it&quot; concepts -- I 
personally find great advantage in programming my data types with semantic 
meaning (meaning to the computer, not just a variable name that solely has 
meaning to programmer) and I also am finding semantic processing to not just be 
fun but a really valuable addition to my toolbox.&nbsp; The ironic thing is that 
semantic programming harks back to
<a href="http://www.codeproject.com/Articles/2342/Organic-Programming-Environment-OPEN">
the very first article</a> I ever wrote for Code Project in 2002.&nbsp; However, 
semantic types / programming is not everyone's cup of tea and definitely 
requires the buy-in of everyone on the team.&nbsp; I've even encountered 
resistance to something as fundamental as a state manager, which really 
surprised me.&nbsp; If you do any Android programming, you'll find shades of 
service management and the publisher/subscriber system that is the underpinning 
of semantic processing, but in my limited experience, I find that these features 
are either under-utilized or used in a way that creates a spaghetti code of 
asynchronous events, lacking the full context of a semantic &quot;data bus.&quot;</p>
<p>Regardless, take something (or nothing) from this article, but hopefully it 
will be of service (haha) to some.</p>
<h2>The MARS Principle: Modular, Abstract, only what's Required, and Simple</h2>
<p>Firstly, I always find it useful to consider the MARS principle whenever 
approaching a requirement.&nbsp; You'll see this principle applied throughout 
the code examples in this article.</p>
<h3>Modular</h3>
<p>It's a lot easier to swap out a module that does A for module that does B 
than it is to find all the places your code is entangled in its implementation 
of A and recode it to implement B.&nbsp; </p>
<ul>
	<li>Modular in part means that your code is organized and implemented in 
	neat &quot;computational islands&quot; with clearly defined entry points and return 
	values.&nbsp; </li>
<li>Modular also means that your implementation isn't hardwired -- it can be 
easily swapped out, not by recompiling the code, but ideally by simply 
specifying a different module.&nbsp; </li>
</ul>
<p>Modular design also keeps your overall implementation &quot;tight&quot; -- All your 
function calls go through the module rather than cut &amp; paste implementation 
scattered throughout your code.</p>
<h3>Abstract</h3>
<p>To achieve simple, you also need to consider the requirement not in terms of 
the specific requirement, but how to express the requirement generally.&nbsp; 
You can then implement a simple abstraction (it may be as simple as an interface 
that defines behavior) so that when the implementation needs to be complex, 
you're deriving from a simpler implementation.</p>
<h3>Only what is Required</h3>
<p>Too many times, classes get overloaded with functions that, while they might 
make the class smarter, are outside of the actual requirements of the class, and 
in fact, the implementation should be put outside as well.&nbsp; We'll see a few 
examples of this later on.</p>
<h3>Simple</h3>
<p>Don't over-think the requirement (but do <i>think</i> about the requirement).&nbsp; 
Don't just reach for a &quot;kitchen sink&quot; third party tool because it claims to do 
what you need.</p>
<h3>Benefits of the MARS Principle - Less Refactoring</h3>
<p>Applying the principles of MARS, you'll discover that you spend considerably 
less time refactoring, especially the large a project is.&nbsp; One actually has 
to laugh at the definition of refactoring: </p>
<p><i>&quot;Code refactoring is the process of restructuring existing computer code – 
changing the factoring – without changing its external behavior. Refactoring 
improves nonfunctional attributes of the software. Advantages include improved 
code readability and reduced complexity; these can improve source code 
maintainability and create a more expressive internal architecture or object 
model to improve extensibility.&quot; (<a href="https://en.wikipedia.org/wiki/Code_refactoring">https://en.wikipedia.org/wiki/Code_refactoring</a>)
</i></p>
<p>Wouldn't it be better to properly design an application from the beginning 
rather than later &quot;improving&quot; it with no visible external changes in behavior?&nbsp; 
In other words, refactoring is usually a waste of time.&nbsp; When I apply the 
MARS principle, experience has shown me that I spend time <i>extending</i> and <i>
improving</i> behaviors rather than rewriting &quot;nonfunctional attributes&quot; of the 
code.&nbsp; When I don't apply the MARS principle, guess what?&nbsp; I end up 
wasting my time (and the client's dollar) refactoring.</p>
<h2>Foundational Principles - Verifying Expectations</h2>
<p>Two of the basic principles of defensive programming are to verify that the:</p>
<ol>
	<li>parameters passed in by the caller meet the requirements of the callee 
	and output values meet the requirements of the caller (contract programming)</li>
	<li>internal state of the function stays valid </li>
</ol>
<p>Contract programming is built into many languages.&nbsp; In C#, there are a 
variety of options such as Microsoft's
<a href="https://github.com/Microsoft/CodeContracts">Code Contracts</a>, but as 
usual, I prefer something considerably simpler.&nbsp; To that end, I use just two &quot;assertion&quot; helpers:</p>
<pre>/// &lt;summary&gt;
/// Assert that the condition is false.
/// &lt;/summary&gt;
[Conditional(&quot;DEBUG&quot;)]
public static void Not(bool b, string msg)
{
  That(!b, msg);
}

/// &lt;summary&gt;
/// Assert that the condition is true.
/// &lt;/summary&gt;
[Conditional(&quot;DEBUG&quot;)]
public static void That(bool b, string msg)
{
  if (!b)
  {
    throw new ApplicationException(msg);
  }
}</pre>
<p>The <code>ConditionalAttribute</code> removes the assertion call when the 
code is compiled in &quot;release mode&quot; -- though you may prefer to keep the 
assertions in place even in release mode.</p>
<h2>Foundational Principles - Critical Error Handling and Logging</h2>
<p>Two concrete foundational principles should always be implemented first: 
critical error handling and logging.&nbsp; Ask yourself:</p>
<ul>
	<li>What mechanisms exist in the language or framework that provide global 
	exception handling?</li>
	<li>How do I want to log these exceptions?</li>
</ul>
<p>I'm not talking about how you handle state recovery and user reporting of 
problems that you've explicitly implemented try-catch handlers for.&nbsp; I'm 
talking about being able to log the error from scenarios you didn't consider.&nbsp; We'll look at 
both console and WinForm exception handling for both application exceptions and 
thread exceptions.</p>
<h3>Console Exception Handling</h3>
<p>In console applications, we really only need to hook <code>AppDomain.UnhandledException</code>.  It is worth reading about <code>AppDomain.UnhandledException</code>
<a href="https://msdn.microsoft.com/en-us/library/system.appdomain.unhandledexception.aspx">
here</a>, as the behavior of this handler is different for different versions of 
.NET!&nbsp; Here's a simple example that lets you test both main thread and 
worker thread exceptions:</p>
<pre>static void Main(string[] args)
{
  Console.WriteLine(&quot;Main thread ID:&quot; + Thread.CurrentThread.ManagedThreadId);
  InitializeGlobalExceptionHandler();

  do
  {
    Console.WriteLine(&quot;(T)hread or (M)ain application exception? &quot;);
    string option = Console.ReadLine();

    switch (option.ToUpper())
    {
      case &quot;T&quot;:
        ThrowThreadException();
        break;

      case &quot;M&quot;:
        ThrowException();
        break;
    }

  } while (true);
}

static void InitializeGlobalExceptionHandler()
{
  AppDomain.CurrentDomain.UnhandledException += GlobalExceptionHandler;
}

static void ThrowException()
{
  throw new ApplicationException(&quot;I blew up.&quot;);
}

static void ThrowThreadException()
{
  Thread t = new Thread(ExceptionalThread);
  Console.WriteLine(&quot;Thread ID: &quot; + t.ManagedThreadId);
  t.Start();
  Thread.Sleep(250);
}

static void ExceptionalThread()
{
  throw new ApplicationException(&quot;Thread blew up.&quot;);
}

static void GlobalExceptionHandler(object sender, UnhandledExceptionEventArgs e)
{
  Console.WriteLine(&quot;Exception in thread ID &quot; + Thread.CurrentThread.ManagedThreadId);
  string msg;

  if (e.ExceptionObject is Exception)
  {
    msg = ((Exception)e.ExceptionObject).Message;
  }
  else
  {
    msg = e.ExceptionObject.GetType().Name;
  }

  Console.WriteLine(&quot;Unhandled exception: &quot; + msg);
  Environment.Exit(1);
}</pre><p>Testing both main and thread exceptions, we see respectively:</p>
<p>
<img border="0" src="The%20Clifton%20Method/ex4.png" width="351" height="168"><img border="0" src="The%20Clifton%20Method/ex5.png" width="365" height="182"></p>
<p>
Notice that the exception handler exits with a call to <code>Environment.Exit(1)</code>.&nbsp; 
If we don't do this, we get a second console message:</p>
<p>
<img border="0" src="The%20Clifton%20Method/ex9.png" width="785" height="131"></p>
<p>
as well as an annoying dialog:</p>
<p>
<img border="0" src="The%20Clifton%20Method/ex8.png" width="458" height="210"></p>
<p>
There are other ways around this, see in particular the documentation for 
<code>WerAddExcludedApplication</code> and <code>SetErrorMode</code>.</p>
<h3>WinForm Exception Handling</h3>
<p>WinForm exception handling is a bit different.&nbsp; We'll put together a 
simple app (Example5 project):</p>
<p>
<img border="0" src="The%20Clifton%20Method/ex6.png" width="319" height="156"></p>
<pre>private void btnAppThreadException_Click(object sender, EventArgs e)
{
  throw new ApplicationException(&quot;I blew up.&quot;);
}

private void btnThreadException_Click(object sender, EventArgs e)
{
  ThrowThreadException();
}

static void ThrowThreadException()
{
  Thread t = new Thread(ExceptionalThread);
  Console.WriteLine(&quot;Thread ID: &quot; + t.ManagedThreadId);
  t.Start();
  Thread.Sleep(250);
}

static void ExceptionalThread()
{
  throw new ApplicationException(&quot;Thread blew up.&quot;);
}</pre>
<p>In a WinForm application, two event handler need to be implemented:</p>
<pre>AppDomain.CurrentDomain.UnhandledException += OnThreadException;
Application.ThreadException += OnThreadException;</pre>
<p>This is somewhat non-intuitive as UnhandledException is called when an 
exception occurs in a thread, and ThreadException is called when an exception 
occurs in the main application thread. </p>
<pre>static void OnUnhandledException(object sender, UnhandledExceptionEventArgs e)
{
  string msg;

  if (e.ExceptionObject is Exception)
  {
    msg = ((Exception)e.ExceptionObject).Message;
  }
  else
  {
    msg = e.ExceptionObject.GetType().Name;
  }

  msg = msg + &quot;\r\n&quot; + Thread.CurrentThread.ManagedThreadId;

  // Bad - we're calling this on a non-UI thread.
  MessageBox.Show(msg, &quot;Something broke!&quot;, MessageBoxButtons.OK, MessageBoxIcon.Error);
  // Application.Exit() will still give us the &quot;windows is checking for a solution&quot; dialog.
  Environment.Exit(1);
}

static void OnThreadException(object sender, ThreadExceptionEventArgs e)
{
  string msg = e.Exception.Message + &quot;\r\n&quot; + Thread.CurrentThread.ManagedThreadId;
  MessageBox.Show(msg, &quot;Main Thread&quot;, MessageBoxButtons.OK, MessageBoxIcon.Error);
}</pre>
<p>As an aside, we can control whether the application exits after a UI event exception or whether it continues operation.&nbsp; Setting the unhandled 
exception mode the throw will cause the application to exit:</p>
<pre>Application.SetUnhandledExceptionMode(UnhandledExceptionMode.ThrowException);</pre>
<p>Setting the unhandled exception mode the catch will cause the application to 
continue:</p>
<pre>Application.SetUnhandledExceptionMode(UnhandledExceptionMode.CatchException, true);</pre>
<p>This setting doesn't affect the threaded exception handler--when a thread 
throws an exception, the application always exists, and again we use 
Environment.Exit(1) to prevent any further annoying JIT/Windows popup.</p>
<p>In any case, we now get for main the worker thread exceptions, respectively:</p>
<p>
<img border="0" src="The%20Clifton%20Method/ex10.png" width="202" height="220"><img border="0" src="The%20Clifton%20Method/ex11.png" width="244" height="220"></p>
<h3>Conclusion to Critical Exception Handling</h3>
<p>Critical exceptions are catastrophic, in that the application will usually 
terminate.&nbsp; The above discussion is a last stop-gap measure for logging 
such failures and should quite clearly demonstrate two other factors:</p>
<ol>
	<li>A robust application incorporates exception handling that can recover 
	the application to a sane state.</li>
	<li>Threads must always have a try-catch block or utilize a class that wraps 
	that the thread in an exception handler.</li>
</ol>
<p>We will visit these two issues again later.&nbsp; Furthermore, critical 
failure exception handling can in reality be considered a kind of service 
(granted, a rather terminal service.)&nbsp; So we will revisit exception 
handling again in the next section on services.</p>
<h3>Logging </h3>
<p>Exception handling is one obvious place where logging the error and reporting 
it somehow to the developer and/or the help desk is important.&nbsp; There are a 
lot of options out there besides Debug.WriteLine, two of which are
<a href="https://github.com/soygul/NBug">NBug</a> and
<a href="https://logging.apache.org/log4net/">Log4Net</a>.&nbsp; Personally, I 
prefer sending logs and errors to <a href="https://papertrailapp.com">
PaperTrailApp</a>, which I've written about
<a href="http://www.codeproject.com/Articles/843938/Logging-With-PaperTrail-Directly-In-Your-Applicati">
here</a>.&nbsp; As with anything the thing with logging is, you may want to 
change how you do your logging, even implement different loggers for different 
kinds of errors.&nbsp; So, we'll revisit logging after talking about services.</p>
<h2>Semantic Data Types</h2>
<p>I realize there are those that either disagree or may think that I'm going 
overboard with semantic data types, but I have found time and time again that 
eliminating native types and instead creating &quot;strong types&quot; facilitates static 
type checking and improves code readability and re-use.&nbsp; I've written an 
article about strong type checking with semantic types
<a href="http://www.codeproject.com/Articles/1031504/Strong-Type-Checking-with-Semantic-Types">
here</a>, and the following is the code from that article, with some 
modifications suggested by readers:</p>
<pre>/// &lt;summary&gt;
/// Topmost abstraction.
/// &lt;/summary&gt;
public interface ISemanticType
{
}

public interface ISemanticType&lt;T&gt;
{
  T Value { get; }
}

/// &lt;summary&gt;
/// Enforces a semantic type of type T with a setter.
/// &lt;/summary&gt;
/// &lt;typeparam name=&quot;T&quot;&gt;The native type.&lt;/typeparam&gt;
public abstract class SemanticType&lt;T&gt; : ISemanticType&lt;T&gt;
{
  public virtual T Value { get; protected set; }
}

/// &lt;summary&gt;
/// Abstract native semantic type. Implements the native type T and the setter/getter.
/// This abstraction implements an immutable native type due to the fact that the setter
/// always returns a new concrete instance.
/// &lt;/summary&gt;
/// &lt;typeparam name=&quot;R&quot;&gt;The concrete instance.&lt;/typeparam&gt;
/// &lt;typeparam name=&quot;T&quot;&gt;The native type backing the concrete instance.&lt;/typeparam&gt;
public abstract class ImmutableSemanticType&lt;R, T&gt; : SemanticType&lt;T&gt;
  where R : ImmutableSemanticType&lt;R, T&gt;, new()
{
  public static R Create(T val)
  {
    R ret = new R();
    ret.Value = val;

    return ret;
  }
}</pre>
<p>We'll see semantic types used later.</p>
<h2>The Service Manager</h2>
<p>Everything we write in code can be considered a service to something else, 
usually another service.&nbsp; In nature, the structures inside our cells are 
services to the whole cell, the cell is a service to an organ, the organs a 
service to our body, we provide services to other people, even the angels 
provide services to us (and sometimes people are in service of the devil.)&nbsp; 
A fundamental tenet of the Clifton Method is that everything, and I mean 
everything, 
can be implemented as a service.</p>
<p>We define a service as a class implementing, at a minimum, an empty interface:</p>
<pre>public interface IService
{
}</pre>
<p>Keeping in line with our MARS principle, a simple service provider can be 
implemented in which services can register themselves.&nbsp; There are of course 
other implementation, such as reflecting over an assembly and determining which classes 
implement <code>IService</code>, but this is a more complicated implementation 
and possibly involves attributes decorating the class implementing the service 
and so forth.&nbsp; Furthermore, such behavior violates the &quot;Requirement&quot; 
principle: it is technically outside the purview of the service provider--it is 
actually part of a process that registers services into the provider!</p>
<p>Again, to maintain a level of abstraction, the concrete service provider 
implements a small interface:</p>
<pre>public interface IServiceManager : IService
{
  void Register&lt;I, S&gt;(ConstructionOption option = ConstructionOption.SingletonOrInstance)
    where I : IService
    where S : IService;

  T GetInstance&lt;T&gt;()
    where T : IService;

  T GetSingleton&lt;T&gt;() 
    where T : IService;
}</pre>
<p>Rather than calling the interface <code>IServiceProvider</code>, I am using 
<code>IServiceManager</code> so as not to conflict with <code>System.IServiceProvider</code>.</p>
<p>Why the two methods for getting either an instance or a singleton?&nbsp; The 
answer is because a service provider doesn't know whether the caller wants a 
unique instance or a shared instance of a service.&nbsp; Furthermore, the 
determination of whether a service should allow multiple instances or allow a 
singleton instance is really up to the service itself.&nbsp; A service 
communicating with a physical device like a card reader may allow only a single 
instance, whereas a service handling a REST requests may allow multiple 
instances.</p>
<p>The implementation also considers that we want to be thread safe--we don't 
know whether services are going to be created or requested just on the main thread, and we 
don't want to restrict the programmer to single threaded operation., hence the 
use of a <code>ConcurrentDictionary</code> and the lock around creating singletons.</p>
<pre>public enum ConstructionOption
{
  SingletonOrInstance,
  AlwaysInstance,
  AlwaysSingleton,
}

public class ServiceManager : IServiceManager
{
  protected ConcurrentDictionary&lt;Type, Type&gt; interfaceServiceMap;
  protected ConcurrentDictionary&lt;Type, IService&gt; singletons;
  protected ConcurrentDictionary&lt;Type, ConstructionOption&gt; constructionOption;

  protected object locker = new object();

  public ServiceManager()
  {
    interfaceServiceMap = new ConcurrentDictionary&lt;Type, Type&gt;();
    singletons = new ConcurrentDictionary&lt;Type, IService&gt;();
    constructionOption = new ConcurrentDictionary&lt;Type, ConstructionOption&gt;();
  }

  /// &lt;summary&gt;
  /// Register a service S that implements interface I.
  /// Both S and I must implement IService.
  /// &lt;/summary&gt;
  public virtual void Register&lt;I, S&gt;(ConstructionOption option = ConstructionOption.SingletonOrInstance)
    where I : IService
    where S : IService
  {
    Type interfaceType = typeof(I);
    Type serviceType = typeof(S);
    Assert.Not(interfaceServiceMap.ContainsKey(interfaceType), &quot;The service &quot; + GetName&lt;S&gt;() + &quot; has already been registered.&quot;);
    interfaceServiceMap[interfaceType] = serviceType;
    constructionOption[interfaceType] = option;
  }

  /// &lt;summary&gt;
  /// If allowed, returns a new instance of the service implement interface T.
  /// &lt;/summary&gt;
  public virtual T GetInstance&lt;T&gt;() 
    where T : IService
  {
    VerifyRegistered&lt;T&gt;();
    VerifyInstanceOption&lt;T&gt;();
    IService instance = CreateInstance&lt;T&gt;();

    return (T)instance;
  }

  /// &lt;summary&gt;
  /// If allowed, creates and registers or returns an existing service that implements interface T.
  /// &lt;/summary&gt;
  public virtual T GetSingleton&lt;T&gt;() 
    where T : IService
  {
    VerifyRegistered&lt;T&gt;();
    VerifySingletonOption&lt;T&gt;();
    Type t = typeof(T);
    IService instance;

    lock (locker)
    {
      if (!singletons.TryGetValue(t, out instance))
      {
        instance = CreateInstance&lt;T&gt;();
        Register&lt;T&gt;(instance);
      }
    }

    return (T)instance;
  }

  /// &lt;summary&gt;
  /// Interface T must be registered.
  /// &lt;/summary&gt;
  protected void VerifyRegistered&lt;T&gt;()
    where T : IService
  {
    Type t = typeof(T);
    Assert.That(interfaceServiceMap.ContainsKey(t), &quot;The service &quot; + GetName&lt;T&gt;() + &quot; has not been registered.&quot;);
  }

  /// &lt;summary&gt;
  /// Create and return the concrete instance that implements service interface T.
  /// &lt;/summary&gt;
  protected IService CreateInstance&lt;T&gt;()
    where T : IService
  {
    Type t = typeof(T);
    IService instance = (IService)Activator.CreateInstance(interfaceServiceMap[t]);

    return instance;
  }

  /// &lt;summary&gt;
  /// Register the service instance that implements the service interface T into the singleton dictionary.
  /// &lt;/summary&gt;
  protected void Register&lt;T&gt;(IService instance)
    where T : IService
  {
    Type t = typeof(T);
    singletons[t] = instance;
  }

  protected void VerifyInstanceOption&lt;T&gt;()
    where T : IService
  {
    Type t = typeof(T);
    ConstructionOption opt = constructionOption[t];
    Assert.That(opt == ConstructionOption.AlwaysInstance || opt == ConstructionOption.SingletonOrInstance, &quot;The service &quot; + GetName&lt;T&gt;() + &quot; does not support instance creation.&quot;);
  }

  protected void VerifySingletonOption&lt;T&gt;()
    where T : IService
  {
    Type t = typeof(T);
    ConstructionOption opt = constructionOption[t];
    Assert.That(opt == ConstructionOption.AlwaysSingleton || opt == ConstructionOption.SingletonOrInstance, &quot;The service &quot; + GetName&lt;T&gt;() + &quot; does not support singleton creation.&quot;);
  }

  protected string GetName&lt;T&gt;()
  {
    return typeof(T).Name;
  }
}
</pre>
<p>If you're wondering why I'm using <code>lock(locker)</code> instead of <code>lock(this)</code>, the 
reason is, code that has a reference to the <code>ServiceManager</code> can lock on it 
without the <code>ServiceManager</code> knowing about it, thus creating potential deadlock 
situations.&nbsp; By using an internal locking object, we prevent accidental 
deadlocks.</p>
<p>The above code also makes the assumption that, once created, a service 
instance can never be deleted (garbage collected.)&nbsp; This feature should be 
done through a different concrete implementation of the service provider, or a 
derived implementation.</p>
<p><img border="0" src="The%20Clifton%20Method/note.png" width="24" height="32"> 
You will note that I never use the <code>private</code> keyword.&nbsp; Private fields and 
members are usually antithetical to abstraction and should only be used when the 
data type is intended to really and truly be private.&nbsp; You will also note 
that most of my public methods are declared as virtual -- again, this supports 
abstraction even though there is a small performance overhead.&nbsp; You'll note 
that I also never use the <code>sealed</code> keyword.</p>
<h3>Two Useful Services</h3>
<p>Now that we have a core component in place, let's look at using it to create 
some useful services.</p>
<h4>Logging as a Service</h4>
<p>Let's revisit logging, this time as a service.&nbsp; We can implement a 
logging service:</p>
<pre>public class LogMessage : ImmutableSemanticType&lt;LogMessage, string&gt; { };
public class ExceptionMessage : ImmutableSemanticType&lt;ExceptionMessage, string&gt; { };

public interface ILoggerService : IService
{
  void Log(LogMessage msg);
  void Log(ExceptionMessage msg);
  void Log(Exception ex);
}</pre>
<p>Here we see our first use of semantic types.&nbsp; Certainly, there can be 
some argument about the implementation -- for example, there could be a single 
Log function that, in addition to the message, takes an optional &quot;criticality&quot; 
parameter.&nbsp; That's certainly a viable implementation as well!</p>
<p>Here's a console logger implementation:</p>
<pre>public interface IConsoleLoggerService : ILoggerService { }

public class LoggerService : IConsoleLoggerService
{
  public virtual void Log(LogMessage msg)
  {
    Console.WriteLine(DateTime.Now.ToString(&quot;MM/dd/yyyy HH:mm:ss : &quot;) + msg.Value);
  }

  public virtual void Log(ExceptionMessage msg)
  {
    Console.WriteLine(DateTime.Now.ToString(&quot;MM/dd/yyyy HH:mm:ss : &quot;) + msg.Value);
  }

  public virtual void Log(Exception ex)
  {
    Console.WriteLine(DateTime.Now.ToString(&quot;MM/dd/yyyy HH:mm:ss : &quot;) + ex.Message);
  }
}</pre>
<p>Now we can change our exception handler to use the logging service (as an 
example):</p>
<pre>static void GlobalExceptionHandler(object sender, UnhandledExceptionEventArgs e)
{
  ILogger logger = serviceManager.GetSingleton&lt;ILogger&gt;();

  if (e.ExceptionObject is Exception)
  {
    logger.Log((Exception)e.ExceptionObject);
  }
  else
  {
    logger.Log(ExceptionMessage.Create(e.ExceptionObject.GetType().Name));
  }

  Environment.Exit(1);
}</pre>
<p>While it may seem overly complicated, remember that I'm presenting only a 
trivial example to illustrate how both the service manager and semantic types 
work together to provide what I consider to be not just very readable code but 
also very modular code.</p>
<h4>Application Configuration Data as a Service</h4>
<p>While application configuration often comes from the &quot;exe.config&quot; file, it 
can also be obtained from any number of other sources -- external XML files, 
database, values acquired from a REST call, the registry, and so forth.&nbsp; 
The process of getting application configuration data is often useful as a 
service rather than hard-wired into application itself.</p>
<p>A basic application configuration service interface looks like this:</p>
<pre>public interface IConfigService : IService
{
  string GetConnectionString(string key);
  string GetValue(string key);
}</pre>
<p>The interface above defines the common behavior of all application config 
services.</p>
<pre>public interface IAppConfigService : IConfigService { }</pre>
<p>The interface above specifies a concrete interface that will be implemented 
by a class that reads the application's config file:</p>
<pre>public virtual class ConfigService : IAppConfigService
{
  public string GetConnectionString(string key)
  {
    return ConfigurationManager.ConnectionStrings[key].ConnectionString;
  }

  public virtual string GetValue(string key)
  {
    return ConfigurationManager.AppSettings[key];
  }
}</pre>
<p>It would be nice to implement other logging options, and now that we have an 
application configuration service, we can get configuration information for 
other loggers, for example, logging to PaperTrailApp.&nbsp; But first, we need 
another incredibly useful building block, the module manager.</p>
<h2>The Module Manager Service</h2>
<p>The module manager is itself a service.&nbsp; It's role is to load specified 
modules (assemblies) that implement services and allow them to register 
themselves with the service provider.&nbsp; This enables us to configure 
applications with the specific service implementations that comprise the 
application--in other words, applications are built from service building 
blocks.&nbsp; The workhorse for the module manager is the <code>RegisterModules</code> 
method, which:</p>
<ul>
	<li>parses an XML file</li>
	<li>loads the assemblies associated with the filenames</li>
	<li>instantiates the registration class that implements <code>IModule</code></li>
	<li>and then calls the Initialize method so that the module can (usually) 
	register its services.</li>
</ul>
<p>The rest of the methods in the class below support the above behavior.</p>
<pre>public class ModuleManager : IModuleManager
{
  protected IServiceManager serviceManager;

  public ModuleManager()
  {
  }

  public void Initialize(IServiceManager svcMgr)
  {
    serviceManager = svcMgr;
  }

  /// &lt;summary&gt;
  /// Register all modules specified in the XML filename so that the application
  /// can gain access to the services provided in those modules.
  /// &lt;/summary&gt;
  public virtual void RegisterModules(XmlFileName filename)
  {
    List&lt;AssemblyFileName&gt; moduleFilenames = GetModuleList(filename);
    List&lt;Assembly&gt; modules = LoadModules(moduleFilenames);
    List&lt;IModule&gt; registrants = InstantiateRegistrants(modules);
    InitializeRegistrants(registrants);
  }

  /// &lt;summary&gt;
  /// Return the list of assembly names specified in the XML file so that
  /// we know what assemblies are considered modules as part of the application.
  /// &lt;/summary&gt;
  protected virtual List&lt;AssemblyFileName&gt; GetModuleList(XmlFileName filename)
  {
    Assert.That(File.Exists(filename.Value), &quot;Module definition file &quot; + filename.Value + &quot; does not exist.&quot;);
    XDocument xdoc = XDocument.Load(filename.Value);
    return GetModuleList(xdoc);
  }

  /// &lt;summary&gt;
  /// Load the assemblies and return the list of loaded assemblies. In order to register
  /// services that the module implements, we have to load the assembly.
  /// &lt;/summary&gt;
  protected virtual List&lt;Assembly&gt; LoadModules(List&lt;AssemblyFileName&gt; moduleFilenames)
  {
    List&lt;Assembly&gt; modules = new List&lt;Assembly&gt;();

    moduleFilenames.ForEach(a =&gt;
    {
      Assembly assembly = LoadAssembly(a);
      modules.Add(assembly);
    });

    return modules;
  }

  /// &lt;summary&gt;
  /// Load and return an assembly given the assembly filename so we can proceed with
  /// instantiating the module and so the module can register its services.
  /// &lt;/summary&gt;
  protected virtual Assembly LoadAssembly(AssemblyFileName assyName)
  {
    FullPath fullPath = GetFullPath(assyName);
    Assembly assembly = Assembly.LoadFile(fullPath.Value);

    return assembly;
  }

  /// &lt;summary&gt;
  /// Returns the list of modules specified in the XML document so we know what
  /// modules to instantiate.
  /// &lt;/summary&gt;
  protected virtual List&lt;AssemblyFileName&gt; GetModuleList(XDocument xdoc)
  {
    List&lt;AssemblyFileName&gt; assemblies = new List&lt;AssemblyFileName&gt;();
      (from module in xdoc.Element(&quot;Modules&quot;).Elements(&quot;Module&quot;)
      select module.Attribute(&quot;AssemblyName&quot;).Value).ForEach(s =&gt; assemblies.Add(AssemblyFileName.Create(s)));

    return assemblies;
  }

  /// &lt;summary&gt;
  /// Instantiate and return the list of registratants -- assemblies with classes that implement IModule.
  /// The registrants is one and only one class in the module that implements IModule, which we can then
  /// use to call the Initialize method so the module can register its services.
  /// &lt;/summary&gt;
  protected virtual List&lt;IModule&gt; InstantiateRegistrants(List&lt;Assembly&gt; modules)
  {
    List&lt;IModule&gt; registrants = new List&lt;IModule&gt;();
    modules.ForEach(m =&gt;
    {
      IModule registrant = InstantiateRegistrant(m);
      registrants.Add(registrant);
    });

    return registrants;
  }

  /// &lt;summary&gt;
  /// Instantiate a registrant. A registrant must have one and only one class that implements IModule.
  /// The registrant is one and only one class in the module that implements IModule, which we can then
  /// use to call the Initialize method so the module can register its services.
  /// &lt;/summary&gt;
  protected virtual IModule InstantiateRegistrant(Assembly module)
  {
    var classesImplementingInterface = module.GetTypes().
      Where(t =&gt; t.IsClass).
      Where(c =&gt; c.GetInterfaces().Where(i =&gt; i.Name == &quot;IModule&quot;).Count() &gt; 0);

    Assert.That(classesImplementingInterface.Count() &lt;= 1, &quot;Module can only have one class that implements IModule&quot;);
    Assert.That(classesImplementingInterface.Count() != 0, &quot;Module does not have any classes that implement IModule&quot;);

    Type implementor = classesImplementingInterface.Single();
    IModule instance = Activator.CreateInstance(implementor) as IModule;

    return instance;
  }

  /// &lt;summary&gt;
  /// Initialize each registrant by passing in the service manager. This allows the module
  /// to register the services it provides.
  /// &lt;/summary&gt;
  protected virtual void InitializeRegistrants(List&lt;IModule&gt; registrants)
  {
    registrants.ForEach(r =&gt; r.InitializeServices(serviceManager));
  }

  /// &lt;summary&gt;
  /// Return the full path of the executing application (here we assume that ModuleManager.dll is in that path) and concatenate the assembly name of the module.
  /// .NET requires the the full path in order to load the associated assembly.
  /// &lt;/summary&gt;
  protected virtual FullPath GetFullPath(AssemblyFileName assemblyName)
  {
    string appLocation = Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location);
    string fullPath = Path.Combine(appLocation, assemblyName.Value);

    return FullPath.Create(fullPath);
  }
}
</pre>
<h3>The Logger, Critical Exception Handler, and App Settings&nbsp;and Module 
Services</h3>
<p>With the module and service managers implemented, we can specify our services 
as modules:</p>
<pre>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;
&lt;Modules&gt;
  &lt;Module AssemblyName='Clifton.ConsoleLoggerService.dll'/&gt;
  &lt;Module AssemblyName='Clifton.AppConfigService.dll'/&gt;
  &lt;Module AssemblyName='Clifton.ConsoleCriticalExceptionService.dll'/&gt;
&lt;/Modules&gt;</pre>
<p>Each module implements <code>IModule</code>, for example:</p>
<pre>public class AppConfigModule : IModule
{
  public void InitializeServices(IServiceManager serviceManager)
  {
    serviceManager.RegisterSingleton&lt;IAppConfigService, ConfigService&gt;();
  }
}</pre>
<p>And each service implements IService, for example, in the console critical 
exception service:</p>
<pre>public void Initialize(IServiceManager svcMgr)
{
  serviceManager = svcMgr;
  AppDomain.CurrentDomain.UnhandledException += GlobalExceptionHandler;
}</pre>
<h3>Bootstrapping</h3>
<p>The application bootstrap process requires initializing the service manager 
and the module manager, after that, the rest of the services, implemented in 
modules, initialize themselves:</p>
<pre>serviceManager = new ServiceManager();
serviceManager.Register&lt;IModuleManager, ModuleManager&gt;();

try
{
  IModuleManager moduleMgr = serviceManager.GetSingleton&lt;IModuleManager&gt;();
  moduleMgr.RegisterModules(XmlFileName.Create(&quot;modules.xml&quot;));
}
catch (Exception ex)
{
  Console.WriteLine(ex.Message);
  Environment.Exit(1);
}</pre>
<p>The bootstrapper is wrapped in a try/catch block because we can't guarantee 
that the critical exception handler nor the logger have initialized yet, 
especially if there is some other catastrophic failure in the module load 
process (which is easy to accomplish, for example just misspell a module name or 
have the assembly not be found.)</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p></p>
<p></p>
<p></p>

</body>

</html>